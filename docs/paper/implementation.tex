\section{Implementation}
This section describes the processes that result to the discovery of tainted paths. During the first process, initially all project templates are found. Each template is first compiled in order to gain access to its Abstract Syntax Tree (AST). Then starting from the AST's root, all children nodes are traversed in order to find variable output that uses dangerous filters. In this process, all templates extended or included by the current template are also traversed in order to discover the full path of the potential issues.

Then a second process starts from the project's urls which are passed to a view resolver, so that views, their decorators ~\cite{django_decorators} and the module that they are defined in, are extracted. Consequently, all modules that were found are passed to another component that traverses their AST, in order to find, for each view, which is the corresponding template being rendered and what is the source of the data needed by that template.

The output of these two processes are cross-examined in order to find the complete potentially tainted data path.

%Check if mark_safe is properly explained
Similarly, in order to find occurrences of the \emph{mark\_safe} function within a view, all function calls are being monitored. If a variable is marked as 'safe' by the view, it is kept in a list, so that the process of traversing all templates, also tracks these variables as they contain unsanitized data. 

Pythia works under both python 2.x and 3.x versions and Django 1.8.x until 1.11.x. Django versions before 1.7.x have a vastly different internal representation of the AST node classes, hence we decided to not support it.

\begin{comment}
%Abstract draft

\end{comment}